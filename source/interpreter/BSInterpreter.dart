import '../BSFunction/BSCalculus.dart';
import 'BSCallable.dart';
import 'BSEnvironment.dart';
import 'BSInstance.dart';
import 'BetaScript.dart';
import 'Expr.dart';
import 'Stmt.dart';
import 'Token.dart';
import 'BSClass.dart';
import 'UserRoutine.dart';
import 'nativeGlobals.dart';


class BSInterpreter implements ExprVisitor, StmtVisitor {
  final Environment globals = new Environment(); //Global scope
  final Map<Expr, int> _locals =
      new Map(); //Stores the results generated by Resolver
  Environment _environment; //Current scope

  BSInterpreter() {
    for (String _name in nativeGlobals.keys) globals.define(_name, nativeGlobals[_name]);
    _environment = globals;
  }

  void interpret(List<Stmt> statements) {
    try {
      for (Stmt stmt in statements) {
        _execute(stmt);
      }
    } on RuntimeError catch (e) {
      BetaScript.runtimeError(e);
    }
  }

  void _execute(Stmt stmt) => stmt.accept(this);

  String _stringify(dynamic object) => object?.toString() ?? 'nil';

  @override
  Object visitBinaryExpr(BinaryExpr e) {
    dynamic leftOperand = _evaluate(e.left);
    dynamic rightOperand = _evaluate(e.right);

    switch (e.op.type) {
      case TokenType.MINUS:
        _checkNumberOperands(e.op, leftOperand, rightOperand);
        return leftOperand - rightOperand;
      case TokenType.SLASH:
        _checkNumberOperands(e.op, leftOperand, rightOperand);
        return leftOperand / rightOperand;
      case TokenType.STAR:
        _checkNumberOperands(e.op, leftOperand, rightOperand);
        return leftOperand * rightOperand;
      case TokenType.EXP:
        _checkNumberOperands(e.op, leftOperand, rightOperand);
        return leftOperand ^ rightOperand;
      case TokenType.PLUS:
        _checkStringOrNumberOperands(e.op, leftOperand, rightOperand);
        return leftOperand + rightOperand;

      case TokenType.GREATER:
        return leftOperand > rightOperand;
      case TokenType.GREATER_EQUAL:
        return leftOperand >= rightOperand;
      case TokenType.LESS:
        return leftOperand < rightOperand;
      case TokenType.LESS_EQUAL:
        return leftOperand <= rightOperand;
      case TokenType.EQUAL_EQUAL:
        return _isEqual(leftOperand, rightOperand);
      default:
    }

    return null;
  }

  @override
  visitGroupingExpr(GroupingExpr e) => _evaluate(e.expression);

  @override
  dynamic visitLiteralExpr(LiteralExpr e) => e.value;

  @override
  Object visitUnaryExpr(UnaryExpr e) {
    dynamic operand = _evaluate(e.right);

    switch (e.op.type) {
      case TokenType.MINUS:
        _checkNum(e.op, operand);
        return -operand; //Dynamically typed language - if the conversion from operand to num fails, it is intended behavior
      case TokenType.NOT:
        return !_istruthy(operand);
      //"not" (!) would be here, but i decided to use it for factorials and use the "not" keyword explicitly
      default:
    }

    return null;
  }

  dynamic _evaluate(Expr e) => e.accept(this);

  ///null and false are "falsy", everything else is "truthy" (isn't the value 'true' but can be used in logic as if it was)
  static bool _istruthy(dynamic object) =>
      ((object is bool) ? object : (!object == null));

  static _isEqual(dynamic a, dynamic b) {
    if (a == null && b == null) return true; //null is only equal to null
    if (a == null || b == null) return false;

    return a == b;
  }

  static void _checkNum(Token token, dynamic value) {
    if (!(value is BSFunction))
      throw new RuntimeError(
          value, "Operand for ${token.lexeme} must be function");
  }

  static void _checkNumberOperands(Token token, dynamic left, dynamic right) {
    if (!(left is BSFunction) || !(right is BSFunction))
      throw new RuntimeError(
          token, "Operands for ${token.lexeme} must be functions");
  }

  void _checkStringOrNumberOperands(Token token, dynamic left, dynamic right) {
    try {
      _checkNumberOperands(token, left, right);
    } on RuntimeError {
      if (!(left is String) || !(right is String))
        throw new RuntimeError(
            token, "Operands for ${token.lexeme} must be functions or strings");
    }
  }

  @override
  void visitExpressionStmt(ExpressionStmt stmt) => _evaluate(stmt.expression);

  @override
  void visitPrintStmt(PrintStmt stmt) {
    dynamic value = _evaluate(stmt.expression);

    //calls the appropriate print function
    BetaScript.printCallback(_stringify(value));
  }

  @override
  void visitVarStmt(VarStmt s) {
    //checks for parameters (which only exist in function declarations)
    List<Variable> _variables = null;

    if (s.parameters != null) {
      _variables = List();
      //Checks if each of the parameters is already a Variable, and when they don't exist, create them as variables
      for (Token parameter in s.parameters) {
        Object _variable = _environment.search(parameter);
        if (_variable == null) {
          _variable = variable(parameter.lexeme);
          _environment.define(parameter.lexeme, _variable);
        }
        else if (!(_variable is Variable)) throw new RuntimeError(parameter, "Parameters to a function must always be Variables");
        
        _variables.add(_variable);
      }

      //checks if there are any duplicate variables (not supported)

      for (int i = 0; i < _variables.length; ++i) 
        for (int j = i + 1; j < _variables.length; ++j) 
          if (_variables[i] == _variables[j]) throw new RuntimeError(s.name, "Duplicate parameters not allowed in function variables");
       
    }
    
    Object value = null;
    if (s.initializer != null) {
      value = _evaluate(s.initializer);
    }

    if (_variables != null && value == null) throw new RuntimeError(s.name, "Function variable declarations with explicit parameter lists must always be initialized");
    else if (_variables != null && !(value is BSFunction)) throw new RuntimeError(s.name, "Only function variable declarations may include parameters");
    else if (_variables != null && value is BSFunction) value = (value as BSFunction).withParameters(Set<Variable>.from(_variables));

    _environment.define(s.name.lexeme, value);
  }

  @override
  Object visitVariableExpr(VariableExpr e) => _lookUpVariable(e.name, e);

  @override
  visitAssignExpr(AssignExpr e) {
    Object value = _evaluate(e.value);

    int distance = _locals[e];
    if (distance != null)
      _environment.assignAt(distance, e.name, value);
    else
      globals.assign(e.name, value);

    return value;
  }

  @override
  void visitBlockStmt(BlockStmt s) {
    //Creates a new environment with current environment enclosing it
    executeBlock(s.statements, new Environment(_environment));
  }

  ///Parameters here are the list of statements to run and the environment in which to run them
  void executeBlock(List<Stmt> statements, Environment environment) {
    Environment previous = _environment;
    try {
      _environment = environment;
      for (Stmt s in statements) _execute(s);
    } finally {
      _environment = previous;
    }
  }

  @override
  void visitIfStmt(IfStmt s) {
    if (_istruthy(_evaluate(s.condition)))
      _execute(s.thenBranch);
    else if (s.elseBranch != null) _execute(s.elseBranch);
  }

  @override
  Object visitlogicBinaryExpr(logicBinaryExpr e) {
    Object left = _evaluate(e.left);

    //Circuit-breaker logical expressions:
    //true OR other_expression should return true regardless of other_expression, so it isn't even evaluated
    //false AND other_expression should return false regardless of other_expression, so it isn't even evaluated

    if (e.op.type == TokenType.OR) {
      if (_istruthy(left)) return left;
    } else if (!_istruthy(left)) return left;
    return _evaluate(e.right);
  }

  @override
  void visitWhileStmt(WhileStmt s) {
    while (_istruthy(_evaluate(s.condition))) _execute(s.body);
  }

  @override
  Object visitCallExpr(CallExpr e) {
    Object callee = _evaluate(e.callee);

    if (!(callee is BSCallable))
      throw new RuntimeError(
          e.paren, "Can only call routines, functions and classes.");

    List<Object> arguments = new List();

    for (Expr argument in e.arguments) arguments.add(_evaluate(argument));

    BSCallable function = callee;

    if (arguments.length != function.arity) {
      throw new RuntimeError(e.paren,
          "Expected ${function.arity.toString()} paramenters, but got ${arguments.length.toString()}.");
    }
    if (callee is BSFunction) {
      for (Object a in arguments)
        if (!(a is BSFunction))
          throw new RuntimeError(
              e.paren, "functions only support other functions as parameters.");
    }

    return function.callThing(this, arguments);
  }

  @override
  void visitRoutineStmt(RoutineStmt s) {
    UserRoutine routine = new UserRoutine(s, _environment, false);
    _environment.define(s.name.lexeme, routine);
  }

  @override
  void visitReturnStmt(ReturnStmt s) {
    Object value = (s.value != null) ? _evaluate(s.value) : null;

    throw new Return(value);
  }

  ///Adds a resolved variable from Resolver to the map
  void resolve(Expr e, int depth) {
    _locals[e] = depth;
  }

  ///Retrieves a variable value from the Environment. Do remember that the resolver doesn't deal with global variables,
  ///which are stored directly in globals
  Object _lookUpVariable(Token name, Expr e) {
    int distance = _locals[e];
    if (distance != null)
      return _environment.getAt(distance, name.lexeme);
    else
      return globals.get(name);
  }

  @override
  void visitClassStmt(ClassStmt s) {
    Object superclass = null;
    if (s.superclass != null) {
      superclass = _evaluate(s.superclass);
      if (!(superclass is BSClass))
        throw new RuntimeError(s.superclass.name, "Superclass must be a class");
    }

    _environment.define(s.name.lexeme, null);

    //Creates a new closure containing super, which contains all the methods
    if (s.superclass != null) {
      _environment = new Environment(_environment);
      _environment.define("super", superclass);
    }

    Map<String, UserRoutine> methods = new Map();

    for (RoutineStmt method in s.methods)
      methods[method.name.lexeme] = new UserRoutine(
          method, _environment, method.name.lexeme == s.name.lexeme);

    BSClass bsclass = new BSClass(s.name.lexeme, superclass, methods);

    if (superclass != null) _environment = _environment.enclosing;

    _environment.assign(s.name, bsclass);
  }

  @override
  visitGetExpr(GetExpr e) {
    Object object = _evaluate(e.object);
    if (object is BSInstance) {
      return object.get(e.name);
    }
    throw new RuntimeError(e.name, "Only instances have properties");
  }

  @override
  visitSetExpr(SetExpr e) {
    Object object = _evaluate(e.object);

    if (!(object is BSInstance))
      throw new RuntimeError(e.name, "Only instances have fields");

    Object value = _evaluate(e.value);
    (object as BSInstance).set(e.name, value);
    return value;
  }

  @override
  Object visitThisExpr(ThisExpr e) => _lookUpVariable(e.keyword, e);

  @override
  Object visitSuperExpr(SuperExpr e) {
    int distance = _locals[e];
    BSClass superclass = _environment.getAt(distance, "super");

    //'this' is always contained one closure "inner" than 'super'
    BSInstance object = _environment.getAt(distance - 1, "this");

    //finds the method in the superclass and binds it to 'this'
    UserRoutine method = superclass.findMethod(e.method.lexeme);

    if (method == null)
      throw new RuntimeError(
          e.method, "Undefined property '${e.method.lexeme}'.");

    return method.bind(object);
  }
}

class RuntimeError implements Exception {
  final Token token;
  final String message;

  RuntimeError(Token this.token, String this.message);

  @override
  String toString() => "Runtime Error: '$message' at line ${token.line}";
}

class Return implements Exception {
  final Object value;

  Return(this.value);
}
